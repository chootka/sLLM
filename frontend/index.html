<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Mould Monitor</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 20px;
            background: #0a0a0a;
            color: #e0e0e0;
            position: relative;
        }
        
        .video-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            overflow: hidden;
            background: #000000;
            margin: 0;
            padding: 0;
        }
        
        .video-background iframe {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.5);
            pointer-events: none;
            border: none;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }
        
        /* For screens wider than 16:9, scale video to be wider than viewport */
        @media (min-aspect-ratio: 16/9) {
            .video-background iframe {
                width: calc(100vh * 16 / 9);
                height: 100vh;
                transform: translate(-50%, -50%) scale(1.5);
            }
        }
        
        /* For screens taller than 16:9, scale video to be taller than viewport */
        @media (max-aspect-ratio: 16/9) {
            .video-background iframe {
                width: 100vw;
                height: calc(100vw * 9 / 16);
                transform: translate(-50%, -50%) scale(1.5);
            }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            color: #000000;
            margin-bottom: 30px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: rgba(26, 26, 26, 0.85);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .panel h2 {
            margin-top: 0;
            color: #ecddb1;
            font-size: 1.2em;
        }
        
        .timelapse-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .timelapse-image {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .timeline-scrubber {
            width: 100%;
            margin-top: 10px;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        .timeline-scrubber::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            color: #ecddb1;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-button {
            color: #ecddb1;
            color: #0a0a0a;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
        }
        
        .control-button:hover {
            color: #ecddb1;
            transform: translateY(-2px);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .control-button.danger {
            background: #e74c3c;
            color: white;
        }
        
        .control-button.danger:hover {
            background: #c0392b;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .status-indicator.online {
            background: #95f33c;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.offline {
            background: #e74c3c;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .readings-display {
            font-size: 2em;
            font-weight: 300;
            color: #ecddb1;
            margin: 20px 0;
        }
        
        .timestamp {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }
        
        canvas {
            max-height: 300px;
        }
        
        .environment-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .env-metric {
            background: rgba(255, 193, 7, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .env-metric .value {
            font-size: 2em;
            font-weight: 300;
            color: #ecddb1;
        }
        
        .env-metric .label {
            font-size: 0.9em;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="video-background">
        <iframe 
            src="https://player.vimeo.com/video/1134023587?autoplay=1&loop=1&muted=1&controls=0&background=1&autopause=0&responsive=1" 
            frameborder="0" 
            allow="autoplay; fullscreen; picture-in-picture" 
            allowfullscreen>
        </iframe>
    </div>
    <div id="app">
        <div class="container">
            <h1>ðŸ¦  Slime Mould Monitor</h1>
            
            <div class="grid">
                <!-- Electrical Readings Panel -->
                <div class="panel">
                    <h2>Electrical Activity</h2>
                    <div class="readings-display">
                        {{ currentReading.toFixed(4) }} V
                    </div>
                    <canvas id="readingsChart"></canvas>
                    <div class="timestamp">
                        Last update: {{ lastUpdateTime }}
                    </div>
                </div>
                
                <!-- Timelapse Viewer Panel -->
                <div class="panel">
                    <h2>Visual Timeline</h2>
                    <div class="timelapse-container">
                        <img 
                            v-if="currentImage" 
                            :src="currentImage" 
                            class="timelapse-image"
                            alt="Slime mould"
                        >
                        <div v-else style="height: 300px; display: flex; align-items: center; justify-content: center;">
                            <p>Waiting for first image...</p>
                        </div>
                    </div>
                    <input 
                        type="range" 
                        v-model="timelinePosition" 
                        :max="images.length - 1" 
                        min="0" 
                        class="timeline-scrubber"
                        @input="onTimelineScrub"
                        v-if="images.length > 0"
                    >
                    <div class="timestamp">
                        {{ images.length }} images captured
                    </div>
                </div>
            </div>
            
            <!-- Environmental Monitoring Panel -->
            <div class="panel" v-if="hasEnvironmentalData">
                <h2>Environmental Conditions</h2>
                <div class="environment-display">
                    <div class="env-metric">
                        <div class="value">{{ temperature ? temperature.toFixed(1) : '--' }}Â°C</div>
                        <div class="label">Temperature</div>
                    </div>
                    <div class="env-metric">
                        <div class="value">{{ humidity ? humidity.toFixed(1) : '--' }}%</div>
                        <div class="label">Humidity</div>
                    </div>
                </div>
                <div class="timestamp">
                    {{ environmentUpdateTime }}
                </div>
            </div>
            
            <!-- Control Panel -->
            <div class="panel">
                <h2>Controls</h2>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <button @click="captureImage" class="control-button">
                        Capture Image
                    </button>
                    <button 
                        @click="toggleLight" 
                        :class="['control-button', exposureLightOn ? 'danger' : '']"
                    >
                        {{ exposureLightOn ? 'Turn Off' : 'Turn On' }} Exposure Light
                    </button>
                    <div>
                        <span :class="['status-indicator', isOnline ? 'online' : 'offline']"></span>
                        {{ isOnline ? 'Connected' : 'Disconnected' }}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;
        
        createApp({
            data() {
                return {
                    // API configuration
                    apiUrl: 'http://sllm.local:5000',
                    socket: null,
                    
                    // Electrical readings
                    currentReading: 0,
                    readingsHistory: [],
                    
                    // Environmental data
                    temperature: null,
                    humidity: null,
                    hasEnvironmentalData: false,
                    environmentUpdateTime: 'No data',
                    
                    // Timelapse
                    images: [],
                    timelinePosition: 0,
                    currentImage: null,
                    
                    // System status
                    isOnline: false,
                    exposureLightOn: false,
                    lastUpdateTime: 'Never',
                    
                    // Configuration from server
                    imageCaptureInterval: 300000,  // Default 5 minutes in ms
                    maxExposureDuration: 30,
                    
                    // Intervals
                    imageInterval: null,
                    fallbackInterval: null
                }
            },
            
            mounted() {
                this.initializeChart();
                this.connectSocket();
                this.startImageCapture();
            },
            
            beforeUnmount() {
                // Clean up
                if (this.socket) {
                    this.socket.disconnect();
                }
                if (this.imageInterval) clearInterval(this.imageInterval);
                if (this.fallbackInterval) clearInterval(this.fallbackInterval);
            },
            
            methods: {
                connectSocket() {
                    // Connect to Socket.IO server
                    this.socket = io(this.apiUrl);
                    
                    // Connection events
                    this.socket.on('connect', () => {
                        console.log('Connected to Socket.IO server');
                        this.isOnline = true;
                    });
                    
                    this.socket.on('disconnect', () => {
                        console.log('Disconnected from Socket.IO server');
                        this.isOnline = false;
                    });
                    
                    // Real-time data events
                    this.socket.on('reading_update', (data) => {
                        this.currentReading = data.value;
                        this.lastUpdateTime = new Date(data.datetime).toLocaleTimeString();
                        this.updateChart(data);
                    });
                    
                    this.socket.on('environment_update', (data) => {
                        this.temperature = data.temperature;
                        this.humidity = data.humidity;
                        this.hasEnvironmentalData = true;
                        this.environmentUpdateTime = `Updated: ${new Date(data.datetime).toLocaleTimeString()}`;
                    });
                    
                    this.socket.on('status_update', (data) => {
                        this.exposureLightOn = data.exposure_light;
                    });
                    
                    this.socket.on('light_changed', (data) => {
                        this.exposureLightOn = data.exposure_light;
                    });
                    
                    // Fallback polling for initial data
                    this.fallbackInterval = setInterval(() => {
                        this.checkStatus();
                    }, 5000);
                },
                initializeChart() {
                    const ctx = document.getElementById('readingsChart').getContext('2d');
                    // Store chart instance outside of Vue's reactive system
                    this._chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Voltage (V)',
                                data: [],
                                borderColor: '#a0d468',
                                backgroundColor: 'rgba(160, 212, 104, 0.1)',
                                borderWidth: 2,
                                tension: 0.4,
                                pointRadius: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: '#666',
                                        maxTicksLimit: 6
                                    }
                                },
                                y: {
                                    display: true,
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)'
                                    },
                                    ticks: {
                                        color: '#666'
                                    }
                                }
                            }
                        }
                    });
                },
                startImageCapture() {
                    // Get capture interval from API config
                    this.fetchConfig().then(() => {
                        // Capture image at configured interval
                        this.imageInterval = setInterval(() => {
                            this.captureImage();
                        }, this.imageCaptureInterval);
                        
                        // Initial capture
                        this.captureImage();
                    });
                },
                
                async fetchConfig() {
                    try {
                        const response = await axios.get(`${this.apiUrl}/api/config`);
                        const config = response.data;
                        
                        // Update local settings from server config
                        this.imageCaptureInterval = config.image_capture_interval * 1000; // Convert to ms
                        this.maxExposureDuration = config.max_exposure_duration;
                        
                    } catch (error) {
                        console.warn('Could not fetch config, using defaults');
                        this.imageCaptureInterval = 5 * 60 * 1000; // Default 5 minutes
                        this.maxExposureDuration = 30;
                    }
                },
                updateChart(reading) {
                    const time = new Date(reading.datetime).toLocaleTimeString();
                    
                    this._chart.data.labels.push(time);
                    this._chart.data.datasets[0].data.push(reading.value);
                    
                    // Keep only last 50 points
                    if (this._chart.data.labels.length > 50) {
                        this._chart.data.labels.shift();
                        this._chart.data.datasets[0].data.shift();
                    }
                    
                    this._chart.update('none'); // No animation for smooth updates
                },                
                async captureImage() {
                    try {
                        const response = await axios.post(`${this.apiUrl}/api/capture-image`, {}, {
                            responseType: 'blob'
                        });
                        
                        const imageUrl = URL.createObjectURL(response.data);
                        const imageData = {
                            url: imageUrl,
                            timestamp: new Date().toISOString()
                        };
                        
                        this.images.push(imageData);
                        this.currentImage = imageUrl;
                        this.timelinePosition = this.images.length - 1;
                        
                        // Keep only last 100 images to prevent memory issues
                        if (this.images.length > 100) {
                            URL.revokeObjectURL(this.images[0].url);
                            this.images.shift();
                        }
                    } catch (error) {
                        console.error('Error capturing image:', error);
                    }
                },
                
                onTimelineScrub() {
                    if (this.images.length > 0 && this.timelinePosition < this.images.length) {
                        this.currentImage = this.images[this.timelinePosition].url;
                    }
                },
                
                async toggleLight() {
                    try {
                        const response = await axios.post(`${this.apiUrl}/api/trigger-light`, {
                            state: 'toggle'
                        });
                        
                        this.exposureLightOn = response.data.light_state === 'on';
                    } catch (error) {
                        console.error('Error toggling light:', error);
                    }
                },
                
                async checkStatus() {
                    try {
                        const response = await axios.get(`${this.apiUrl}/api/status`);
                        const status = response.data;
                        
                        this.isOnline = true;
                        this.exposureLightOn = status.exposure_light === 'on';
                        
                        // Update environmental data if available
                        if (status.environment) {
                            this.temperature = status.environment.temperature;
                            this.humidity = status.environment.humidity;
                            this.hasEnvironmentalData = true;
                            this.environmentUpdateTime = `Updated: ${new Date(status.environment.datetime).toLocaleTimeString()}`;
                        }
                    } catch (error) {
                        this.isOnline = false;
                    }
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
